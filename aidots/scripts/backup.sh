#!/usr/bin/env bash
set -euo pipefail

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# backup.sh â€” Back up AI coding tool configs
# Part of the aidots skill
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_DIR="$HOME/.aidots"
CONFIG_FILE="$CONFIG_DIR/config.json"
SCAN_SCRIPT="$SCRIPT_DIR/scan.sh"

# â”€â”€ Defaults â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
BACKUP_DIR=""
NO_PUSH=false
NO_COMMIT=false

# â”€â”€ Dependency check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

check_dependencies() {
    if ! command -v jq &>/dev/null; then
        printf 'Error: jq is required but not installed.\n' >&2
        printf 'Install with: brew install jq\n' >&2
        exit 1
    fi

    if [[ ! -x "$SCAN_SCRIPT" ]]; then
        printf 'Error: scan.sh not found at %s\n' "$SCAN_SCRIPT" >&2
        exit 1
    fi
}

# â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Format byte count to human-readable size
human_size() {
    local bytes=$1
    if (( bytes >= 1048576 )); then
        printf '%.1f MB' "$(echo "scale=1; $bytes / 1048576" | bc)"
    elif (( bytes >= 1024 )); then
        printf '%.1f KB' "$(echo "scale=1; $bytes / 1024" | bc)"
    else
        printf '%d B' "$bytes"
    fi
}

# Expand ~ to $HOME
expand_tilde() {
    local path="$1"
    if [[ "$path" == "~"* ]]; then
        printf '%s' "${HOME}${path#\~}"
    else
        printf '%s' "$path"
    fi
}

# Collapse $HOME to ~ for display
collapse_home() {
    local path="$1"
    if [[ "$path" == "$HOME"* ]]; then
        printf '~%s' "${path#$HOME}"
    else
        printf '%s' "$path"
    fi
}

# Get current timestamp
now_stamp() {
    date '+%Y-%m-%d %H:%M'
}

# Get ISO 8601 timestamp
now_iso() {
    date -u '+%Y-%m-%dT%H:%M:%SZ'
}

# â”€â”€ Config management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Read config.json, print backup_dir. Returns 1 if not found.
read_config() {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        return 1
    fi
    local dir
    dir=$(jq -r '.backup_dir // empty' "$CONFIG_FILE" 2>/dev/null)
    if [[ -z "$dir" ]]; then
        return 1
    fi
    printf '%s' "$(expand_tilde "$dir")"
}

# Interactive first-time setup
init_config() {
    local chosen_dir=""

    printf 'é¦–æ¬¡ä½¿ç”¨ aidotsï¼Œè¯·è®¾ç½®å¤‡ä»½ç›®å½•ï¼š\n'
    printf '  [1] ä½¿ç”¨é»˜è®¤ä½ç½® ~/dotaiï¼ˆæ¨èï¼‰\n'
    printf '  [2] è‡ªå®šä¹‰è·¯å¾„\n'
    printf '\nè¯·é€‰æ‹© [1/2]: '

    local choice
    read -r choice

    case "$choice" in
        2)
            printf 'è¯·è¾“å…¥å¤‡ä»½ç›®å½•è·¯å¾„: '
            local custom_path
            read -r custom_path
            chosen_dir=$(expand_tilde "$custom_path")
            ;;
        *)
            chosen_dir="$HOME/dotai"
            ;;
    esac

    # Create directory if needed
    if [[ ! -d "$chosen_dir" ]]; then
        mkdir -p "$chosen_dir"
    fi

    # Init git repo if not already one
    if [[ ! -d "$chosen_dir/.git" ]]; then
        git -C "$chosen_dir" init -q
    fi

    # Save config
    mkdir -p "$CONFIG_DIR"
    printf '{"backup_dir": "%s", "created_at": "%s"}\n' \
        "$(collapse_home "$chosen_dir")" "$(now_iso)" > "$CONFIG_FILE"

    printf 'âœ… é…ç½®å·²ä¿å­˜åˆ° ~/.aidots/config.json\n\n'

    # Return the chosen dir
    printf '%s' "$chosen_dir"
}

# â”€â”€ File operations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Check if a CLAUDE.md file is auto-generated by claude-mem plugin
is_claude_mem_generated() {
    local filepath="$1"
    if [[ ! -f "$filepath" ]]; then
        return 1
    fi
    local first_line
    first_line=$(head -1 "$filepath" 2>/dev/null || true)
    if [[ "$first_line" == "<claude-mem-context>"* ]]; then
        return 0
    fi
    return 1
}

# Copy files for a single tool. Returns the number of files copied.
# Arguments: tool_id config_dir backup_dir scan_json_files
# scan_json_files is a JSON array string of {path, size} objects
copy_tool_files() {
    local tool_id="$1"
    local config_dir="$2"
    local backup_dir="$3"
    local files_json="$4"

    local tool_backup_dir="${backup_dir}/.${tool_id}"
    local copied=0

    # Iterate over each file in the JSON array
    local file_count
    file_count=$(printf '%s' "$files_json" | jq 'length')

    local i=0
    while (( i < file_count )); do
        local rel_path
        rel_path=$(printf '%s' "$files_json" | jq -r ".[$i].path")

        local source_file="${config_dir}/${rel_path}"

        # Skip CLAUDE.md files that are auto-generated by claude-mem
        local base_name
        base_name=$(basename "$rel_path")
        if [[ "$base_name" == "CLAUDE.md" ]]; then
            if is_claude_mem_generated "$source_file"; then
                i=$((i + 1))
                continue
            fi
        fi

        # Create parent directory and copy
        local dest_file="${tool_backup_dir}/${rel_path}"
        local dest_parent
        dest_parent=$(dirname "$dest_file")
        mkdir -p "$dest_parent"
        cp "$source_file" "$dest_file"

        copied=$((copied + 1))
        i=$((i + 1))
    done

    printf '%d' "$copied"
}

# â”€â”€ README generation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

generate_readme() {
    local backup_dir="$1"
    local scan_json="$2"
    local stamp
    stamp=$(now_stamp)

    local readme_file="${backup_dir}/README.md"
    local tool_count
    tool_count=$(printf '%s' "$scan_json" | jq '[.tools[] | select(.status == "found")] | length')

    {
        printf '# AI Coding Dotfiles\n\n'
        printf '> ç”± [aidots](https://github.com/zhoulianglen/aidots) è‡ªåŠ¨ç”Ÿæˆäº %s\n\n' "$stamp"

        # Summary table
        printf '## å¤‡ä»½çš„å·¥å…·\n\n'
        printf '| å·¥å…· | é…ç½®æ–‡ä»¶æ•° |\n'
        printf '|------|------------|\n'

        printf '%s' "$scan_json" | jq -r '
            .tools[] | select(.status == "found") |
            "| \(.name) | \(.files | length) |"
        '

        printf '\n---\n'

        # Per-tool sections
        printf '%s' "$scan_json" | jq -r '
            .tools[] | select(.status == "found") | .id
        ' | while IFS= read -r tid; do
            local tname
            tname=$(printf '%s' "$scan_json" | jq -r --arg id "$tid" '.tools[] | select(.id == $id) | .name')

            printf '\n## `.%s/` â€” %s\n\n' "$tid" "$tname"
            printf '| æ–‡ä»¶ | å¤§å° |\n'
            printf '|------|------|\n'

            # Get files for this tool â€” we need to compute human sizes in bash
            printf '%s' "$scan_json" | jq -r --arg id "$tid" '
                .tools[] | select(.id == $id) | .files[] |
                "\(.path)\t\(.size)"
            ' | while IFS=$'\t' read -r fpath fsize; do
                local hsize
                hsize=$(human_size "$fsize")
                printf '| %s | %s |\n' "$fpath" "$hsize"
            done
        done

        printf '\n'
    } > "$readme_file"
}

# â”€â”€ Git operations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

git_commit_push() {
    local backup_dir="$1"
    local stamp
    stamp=$(now_stamp)

    local original_dir
    original_dir=$(pwd)

    cd "$backup_dir"

    git add -A

    # Check if there are changes to commit
    if git diff --cached --quiet 2>/dev/null; then
        printf '  â„¹ï¸  æ²¡æœ‰å˜æ›´éœ€è¦æäº¤\n'
        cd "$original_dir"
        return 0
    fi

    git commit -q -m "backup: $stamp"
    printf 'âœ… å·²æäº¤ï¼šbackup: %s\n' "$stamp"

    if ! $NO_PUSH; then
        # Check if remote exists
        if git remote get-url origin &>/dev/null; then
            git push -q
            printf 'ğŸš€ å·²æ¨é€åˆ°è¿œç¨‹ä»“åº“\n'
        fi
    fi

    cd "$original_dir"
}

# â”€â”€ Usage â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

usage() {
    printf 'Usage: %s [--dir <path>] [--no-push] [--no-commit]\n\n' "$(basename "$0")"
    printf 'Options:\n'
    printf '  --dir <path>   Override backup directory\n'
    printf '  --no-push      Commit but do not push\n'
    printf '  --no-commit    Copy files only, no git commit/push\n'
    printf '  --help, -h     Show this help\n'
    exit 0
}

# â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

main() {
    # Parse arguments
    while (( $# > 0 )); do
        case "$1" in
            --dir)
                if [[ -z "${2:-}" ]]; then
                    printf 'Error: --dir requires a path argument\n' >&2
                    exit 1
                fi
                BACKUP_DIR=$(expand_tilde "$2")
                shift 2
                ;;
            --no-push)
                NO_PUSH=true
                shift
                ;;
            --no-commit)
                NO_COMMIT=true
                shift
                ;;
            --help|-h)
                usage
                ;;
            *)
                printf 'Unknown option: %s\n' "$1" >&2
                usage
                ;;
        esac
    done

    check_dependencies

    # Determine backup directory
    if [[ -z "$BACKUP_DIR" ]]; then
        if ! BACKUP_DIR=$(read_config); then
            # First-time setup â€” capture only the last line (the dir path)
            local setup_output
            setup_output=$(init_config)
            BACKUP_DIR=$(printf '%s' "$setup_output" | tail -1)
        fi
    fi

    # Ensure backup dir exists and is a git repo (unless --no-commit)
    if [[ ! -d "$BACKUP_DIR" ]]; then
        mkdir -p "$BACKUP_DIR"
    fi
    if ! $NO_COMMIT && [[ ! -d "$BACKUP_DIR/.git" ]]; then
        git -C "$BACKUP_DIR" init -q
    fi

    printf '\nğŸ“¦ aidots å¤‡ä»½\n\n'
    printf 'å¤‡ä»½ç›®å½•ï¼š%s\n\n' "$(collapse_home "$BACKUP_DIR")"

    # Run scan
    local scan_json
    scan_json=$("$SCAN_SCRIPT" --json)

    # Process each found tool
    local total_tools=0
    local tool_ids
    tool_ids=$(printf '%s' "$scan_json" | jq -r '.tools[] | select(.status == "found") | .id')

    while IFS= read -r tool_id; do
        [[ -z "$tool_id" ]] && continue

        local config_dir
        config_dir=$(printf '%s' "$scan_json" | jq -r --arg id "$tool_id" \
            '.tools[] | select(.id == $id) | .config_dir')

        local tool_name
        tool_name=$(printf '%s' "$scan_json" | jq -r --arg id "$tool_id" \
            '.tools[] | select(.id == $id) | .name')

        local files_json
        files_json=$(printf '%s' "$scan_json" | jq --arg id "$tool_id" \
            '.tools[] | select(.id == $id) | .files')

        local copied
        copied=$(copy_tool_files "$tool_id" "$config_dir" "$BACKUP_DIR" "$files_json")

        printf '  .%s/ â€” %d ä¸ªæ–‡ä»¶å·²å¤åˆ¶\n' "$tool_id" "$copied"
        total_tools=$((total_tools + 1))

    done <<< "$tool_ids"

    printf '\n'

    # Generate README
    generate_readme "$BACKUP_DIR" "$scan_json"
    printf 'ğŸ“ README.md å·²ç”Ÿæˆ\n'

    # Git commit and push
    if ! $NO_COMMIT; then
        git_commit_push "$BACKUP_DIR"
    fi

    printf '\n'
}

main "$@"
