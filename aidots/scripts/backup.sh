#!/usr/bin/env bash
set -euo pipefail

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# backup.sh â€” Back up AI coding tool configs
# Part of the aidots skill
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_DIR="$HOME/.aidots"
CONFIG_FILE="$CONFIG_DIR/config.json"
SCAN_SCRIPT="$SCRIPT_DIR/scan.sh"

# â”€â”€ Defaults â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
BACKUP_DIR=""
NO_PUSH=false
NO_COMMIT=false

# â”€â”€ Locale â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
detect_locale() {
    local lang="${LANG:-${LC_ALL:-${LANGUAGE:-en}}}"
    case "$lang" in
        zh*) printf 'zh' ;;
        *)   printf 'en' ;;
    esac
}

LOCALE=$(detect_locale)

if [[ "$LOCALE" == "zh" ]]; then
    MSG_INIT_PROMPT="é¦–æ¬¡ä½¿ç”¨ aidotsï¼Œè¯·è®¾ç½®å¤‡ä»½ç›®å½•ï¼š"
    MSG_INIT_OPT1="  [1] ä½¿ç”¨é»˜è®¤ä½ç½® ~/dotaiï¼ˆæŽ¨èï¼‰"
    MSG_INIT_OPT2="  [2] è‡ªå®šä¹‰è·¯å¾„"
    MSG_INIT_CHOOSE="è¯·é€‰æ‹© [1/2]: "
    MSG_INIT_CUSTOM="è¯·è¾“å…¥å¤‡ä»½ç›®å½•è·¯å¾„: "
    MSG_CONFIG_SAVED="âœ… é…ç½®å·²ä¿å­˜åˆ° ~/.aidots/config.json"
    MSG_README_GENERATED_BY="ç”± [aidots](https://github.com/zhoulianglen/aidots) è‡ªåŠ¨ç”ŸæˆäºŽ %s"
    MSG_README_TOOLS_HEADING="å¤‡ä»½çš„å·¥å…·"
    MSG_README_TH_TOOL="å·¥å…·"
    MSG_README_TH_FILE_COUNT="é…ç½®æ–‡ä»¶æ•°"
    MSG_README_TH_FILE="æ–‡ä»¶"
    MSG_README_TH_SIZE="å¤§å°"
    MSG_NO_CHANGES="  â„¹ï¸  æ²¡æœ‰å˜æ›´éœ€è¦æäº¤"
    MSG_COMMITTED="âœ… å·²æäº¤ï¼šbackup: %s"
    MSG_PUSHED="ðŸš€ å·²æŽ¨é€åˆ°è¿œç¨‹ä»“åº“"
    MSG_BACKUP_HEADER="ðŸ“¦ aidots å¤‡ä»½"
    MSG_BACKUP_DIR="å¤‡ä»½ç›®å½•ï¼š%s"
    MSG_FILES_COPIED="  .%s/ â€” %d ä¸ªæ–‡ä»¶å·²å¤åˆ¶"
    MSG_README_GENERATED="ðŸ“ README.md å·²ç”Ÿæˆ"
    MSG_README_SKILLS_HEADING="å·²å®‰è£…çš„æŠ€èƒ½"
    MSG_README_TH_SKILL="æŠ€èƒ½"
    MSG_README_TH_DESC="è¯´æ˜Ž"
else
    MSG_INIT_PROMPT="First time using aidots. Please set a backup directory:"
    MSG_INIT_OPT1="  [1] Use default location ~/dotai (recommended)"
    MSG_INIT_OPT2="  [2] Custom path"
    MSG_INIT_CHOOSE="Choose [1/2]: "
    MSG_INIT_CUSTOM="Enter backup directory path: "
    MSG_CONFIG_SAVED="âœ… Config saved to ~/.aidots/config.json"
    MSG_README_GENERATED_BY="Auto-generated by [aidots](https://github.com/zhoulianglen/aidots) on %s"
    MSG_README_TOOLS_HEADING="Backed-up Tools"
    MSG_README_TH_TOOL="Tool"
    MSG_README_TH_FILE_COUNT="Config Files"
    MSG_README_TH_FILE="File"
    MSG_README_TH_SIZE="Size"
    MSG_NO_CHANGES="  â„¹ï¸  No changes to commit"
    MSG_COMMITTED="âœ… Committed: backup: %s"
    MSG_PUSHED="ðŸš€ Pushed to remote"
    MSG_BACKUP_HEADER="ðŸ“¦ aidots Backup"
    MSG_BACKUP_DIR="Backup directory: %s"
    MSG_FILES_COPIED="  .%s/ â€” %d files copied"
    MSG_README_GENERATED="ðŸ“ README.md generated"
    MSG_README_SKILLS_HEADING="Installed Skills"
    MSG_README_TH_SKILL="Skill"
    MSG_README_TH_DESC="Description"
fi

# â”€â”€ Dependency check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

check_dependencies() {
    if ! command -v jq &>/dev/null; then
        printf 'Error: jq is required but not installed.\n' >&2
        printf 'Install with: brew install jq\n' >&2
        exit 1
    fi

    if [[ ! -x "$SCAN_SCRIPT" ]]; then
        printf 'Error: scan.sh not found at %s\n' "$SCAN_SCRIPT" >&2
        exit 1
    fi
}

# â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Format byte count to human-readable size
human_size() {
    local bytes=$1
    if (( bytes >= 1048576 )); then
        printf '%.1f MB' "$(echo "scale=1; $bytes / 1048576" | bc)"
    elif (( bytes >= 1024 )); then
        printf '%.1f KB' "$(echo "scale=1; $bytes / 1024" | bc)"
    else
        printf '%d B' "$bytes"
    fi
}

# Expand ~ to $HOME
expand_tilde() {
    local path="$1"
    if [[ "$path" == "~"* ]]; then
        printf '%s' "${HOME}${path#\~}"
    else
        printf '%s' "$path"
    fi
}

# Collapse $HOME to ~ for display
collapse_home() {
    local path="$1"
    if [[ "$path" == "$HOME"* ]]; then
        printf '~%s' "${path#$HOME}"
    else
        printf '%s' "$path"
    fi
}

# Get current timestamp
now_stamp() {
    date '+%Y-%m-%d %H:%M'
}

# Get ISO 8601 timestamp
now_iso() {
    date -u '+%Y-%m-%dT%H:%M:%SZ'
}

# â”€â”€ Config management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Read config.json, print backup_dir. Returns 1 if not found.
read_config() {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        return 1
    fi
    local dir
    dir=$(jq -r '.backup_dir // empty' "$CONFIG_FILE" 2>/dev/null)
    if [[ -z "$dir" ]]; then
        return 1
    fi
    printf '%s' "$(expand_tilde "$dir")"
}

# Interactive first-time setup
init_config() {
    local chosen_dir=""

    printf '%s\n' "$MSG_INIT_PROMPT"
    printf '%s\n' "$MSG_INIT_OPT1"
    printf '%s\n' "$MSG_INIT_OPT2"
    printf '\n%s' "$MSG_INIT_CHOOSE"

    local choice
    read -r choice

    case "$choice" in
        2)
            printf '%s' "$MSG_INIT_CUSTOM"
            local custom_path
            read -r custom_path
            chosen_dir=$(expand_tilde "$custom_path")
            ;;
        *)
            chosen_dir="$HOME/dotai"
            ;;
    esac

    # Create directory if needed
    if [[ ! -d "$chosen_dir" ]]; then
        mkdir -p "$chosen_dir"
    fi

    # Init git repo if not already one
    if [[ ! -d "$chosen_dir/.git" ]]; then
        git -C "$chosen_dir" init -q
    fi

    # Save config
    mkdir -p "$CONFIG_DIR"
    printf '{"backup_dir": "%s", "created_at": "%s"}\n' \
        "$(collapse_home "$chosen_dir")" "$(now_iso)" > "$CONFIG_FILE"

    printf '%s\n\n' "$MSG_CONFIG_SAVED"

    # Return the chosen dir
    printf '%s' "$chosen_dir"
}

# â”€â”€ File operations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Check if a CLAUDE.md file is auto-generated by claude-mem plugin
is_claude_mem_generated() {
    local filepath="$1"
    if [[ ! -f "$filepath" ]]; then
        return 1
    fi
    local first_line
    first_line=$(head -1 "$filepath" 2>/dev/null || true)
    if [[ "$first_line" == "<claude-mem-context>"* ]]; then
        return 0
    fi
    return 1
}

# Copy files for a single tool. Returns the number of files copied.
# Arguments: tool_id config_dir backup_dir scan_json_files
# scan_json_files is a JSON array string of {path, size} objects
copy_tool_files() {
    local tool_id="$1"
    local config_dir="$2"
    local backup_dir="$3"
    local files_json="$4"

    local tool_backup_dir="${backup_dir}/.${tool_id}"
    local copied=0

    # Iterate over each file in the JSON array
    local file_count
    file_count=$(printf '%s' "$files_json" | jq 'length')

    local i=0
    while (( i < file_count )); do
        local rel_path
        rel_path=$(printf '%s' "$files_json" | jq -r ".[$i].path")

        local source_file="${config_dir}/${rel_path}"

        # Skip CLAUDE.md files that are auto-generated by claude-mem
        local base_name
        base_name=$(basename "$rel_path")
        if [[ "$base_name" == "CLAUDE.md" ]]; then
            if is_claude_mem_generated "$source_file"; then
                i=$((i + 1))
                continue
            fi
        fi

        # Create parent directory and copy
        local dest_file="${tool_backup_dir}/${rel_path}"
        local dest_parent
        dest_parent=$(dirname "$dest_file")
        mkdir -p "$dest_parent"
        cp "$source_file" "$dest_file"

        copied=$((copied + 1))
        i=$((i + 1))
    done

    printf '%d' "$copied"
}

# â”€â”€ Skill metadata extraction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Extract a field from SKILL.md YAML frontmatter
# Usage: extract_skill_field <file> <field>
extract_skill_field() {
    local skill_file="$1"
    local field="$2"
    local in_frontmatter=false

    while IFS= read -r line; do
        if [[ "$line" == "---" ]]; then
            if $in_frontmatter; then
                break
            fi
            in_frontmatter=true
            continue
        fi
        if $in_frontmatter; then
            case "$line" in
                ${field}:*)
                    local value="${line#${field}:}"
                    # Trim whitespace and surrounding quotes
                    value=$(printf '%s' "$value" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
                    value=$(printf '%s' "$value" | sed 's/^"//;s/"$//' | sed "s/^'//;s/'$//")
                    printf '%s' "$value"
                    return 0
                    ;;
            esac
        fi
    done < "$skill_file"
    return 1
}

# â”€â”€ README generation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

generate_readme() {
    local backup_dir="$1"
    local scan_json="$2"
    local stamp
    stamp=$(now_stamp)

    local readme_file="${backup_dir}/README.md"
    local tool_count
    tool_count=$(printf '%s' "$scan_json" | jq '[.tools[] | select(.status == "found")] | length')

    {
        printf '# AI Coding Dotfiles\n\n'
        printf "> ${MSG_README_GENERATED_BY}\n\n" "$stamp"

        # Summary table
        printf '## %s\n\n' "$MSG_README_TOOLS_HEADING"
        printf '| %s | %s |\n' "$MSG_README_TH_TOOL" "$MSG_README_TH_FILE_COUNT"
        printf '|------|------------|\n'

        printf '%s' "$scan_json" | jq -r '
            .tools[] | select(.status == "found") |
            "| \(.name) | \(.files | length) |"
        '

        # Skills section â€” extract descriptions from SKILL.md files
        local skills_dir="${backup_dir}/.claude/skills"
        if [[ -d "$skills_dir" ]]; then
            local skill_files
            skill_files=$(find "$skills_dir" -name "SKILL.md" -type f 2>/dev/null | sort)
            if [[ -n "$skill_files" ]]; then
                printf '\n## %s\n\n' "$MSG_README_SKILLS_HEADING"
                printf '| %s | %s |\n' "$MSG_README_TH_SKILL" "$MSG_README_TH_DESC"
                printf '|------|------|\n'
                while IFS= read -r skill_file; do
                    local sname sdesc
                    sname=$(extract_skill_field "$skill_file" "name") || continue
                    sdesc=$(extract_skill_field "$skill_file" "description") || sdesc=""
                    printf '| %s | %s |\n' "$sname" "$sdesc"
                done <<< "$skill_files"
            fi
        fi

        printf '\n---\n'

        # Per-tool sections
        printf '%s' "$scan_json" | jq -r '
            .tools[] | select(.status == "found") | .id
        ' | while IFS= read -r tid; do
            local tname
            tname=$(printf '%s' "$scan_json" | jq -r --arg id "$tid" '.tools[] | select(.id == $id) | .name')

            printf '\n## `.%s/` â€” %s\n\n' "$tid" "$tname"
            printf '| %s | %s |\n' "$MSG_README_TH_FILE" "$MSG_README_TH_SIZE"
            printf '|------|------|\n'

            # Get files for this tool â€” we need to compute human sizes in bash
            printf '%s' "$scan_json" | jq -r --arg id "$tid" '
                .tools[] | select(.id == $id) | .files[] |
                "\(.path)\t\(.size)"
            ' | while IFS=$'\t' read -r fpath fsize; do
                local hsize
                hsize=$(human_size "$fsize")
                printf '| %s | %s |\n' "$fpath" "$hsize"
            done
        done

        printf '\n'
    } > "$readme_file"
}

# â”€â”€ Git operations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

git_commit_push() {
    local backup_dir="$1"
    local stamp
    stamp=$(now_stamp)

    local original_dir
    original_dir=$(pwd)

    cd "$backup_dir"

    git add -A

    # Check if there are changes to commit
    if git diff --cached --quiet 2>/dev/null; then
        printf '%s\n' "$MSG_NO_CHANGES"
        cd "$original_dir"
        return 0
    fi

    git commit -q -m "backup: $stamp"
    printf "${MSG_COMMITTED}\n" "$stamp"

    if ! $NO_PUSH; then
        # Check if remote exists
        if git remote get-url origin &>/dev/null; then
            git push -q
            printf '%s\n' "$MSG_PUSHED"
        fi
    fi

    cd "$original_dir"
}

# â”€â”€ Usage â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

usage() {
    printf 'Usage: %s [--dir <path>] [--no-push] [--no-commit]\n\n' "$(basename "$0")"
    printf 'Options:\n'
    printf '  --dir <path>   Override backup directory\n'
    printf '  --no-push      Commit but do not push\n'
    printf '  --no-commit    Copy files only, no git commit/push\n'
    printf '  --help, -h     Show this help\n'
    exit 0
}

# â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

main() {
    # Parse arguments
    while (( $# > 0 )); do
        case "$1" in
            --dir)
                if [[ -z "${2:-}" ]]; then
                    printf 'Error: --dir requires a path argument\n' >&2
                    exit 1
                fi
                BACKUP_DIR=$(expand_tilde "$2")
                shift 2
                ;;
            --no-push)
                NO_PUSH=true
                shift
                ;;
            --no-commit)
                NO_COMMIT=true
                shift
                ;;
            --help|-h)
                usage
                ;;
            *)
                printf 'Unknown option: %s\n' "$1" >&2
                usage
                ;;
        esac
    done

    check_dependencies

    # Determine backup directory
    if [[ -z "$BACKUP_DIR" ]]; then
        if ! BACKUP_DIR=$(read_config); then
            # First-time setup â€” capture only the last line (the dir path)
            local setup_output
            setup_output=$(init_config)
            BACKUP_DIR=$(printf '%s' "$setup_output" | tail -1)
        fi
    fi

    # Ensure backup dir exists and is a git repo (unless --no-commit)
    if [[ ! -d "$BACKUP_DIR" ]]; then
        mkdir -p "$BACKUP_DIR"
    fi
    if ! $NO_COMMIT && [[ ! -d "$BACKUP_DIR/.git" ]]; then
        git -C "$BACKUP_DIR" init -q
    fi

    printf '\n%s\n\n' "$MSG_BACKUP_HEADER"
    printf "${MSG_BACKUP_DIR}\n\n" "$(collapse_home "$BACKUP_DIR")"

    # Run scan
    local scan_json
    scan_json=$("$SCAN_SCRIPT" --json)

    # Process each found tool
    local total_tools=0
    local tool_ids
    tool_ids=$(printf '%s' "$scan_json" | jq -r '.tools[] | select(.status == "found") | .id')

    while IFS= read -r tool_id; do
        [[ -z "$tool_id" ]] && continue

        local config_dir
        config_dir=$(printf '%s' "$scan_json" | jq -r --arg id "$tool_id" \
            '.tools[] | select(.id == $id) | .config_dir')

        local tool_name
        tool_name=$(printf '%s' "$scan_json" | jq -r --arg id "$tool_id" \
            '.tools[] | select(.id == $id) | .name')

        local files_json
        files_json=$(printf '%s' "$scan_json" | jq --arg id "$tool_id" \
            '.tools[] | select(.id == $id) | .files')

        local copied
        copied=$(copy_tool_files "$tool_id" "$config_dir" "$BACKUP_DIR" "$files_json")

        printf "${MSG_FILES_COPIED}\n" "$tool_id" "$copied"
        total_tools=$((total_tools + 1))

    done <<< "$tool_ids"

    printf '\n'

    # Generate README
    generate_readme "$BACKUP_DIR" "$scan_json"
    printf '%s\n' "$MSG_README_GENERATED"

    # Git commit and push
    if ! $NO_COMMIT; then
        git_commit_push "$BACKUP_DIR"
    fi

    printf '\n'
}

main "$@"
